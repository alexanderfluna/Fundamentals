http://www.codeproject.com/csharp/cloneimpl_class.asp</br></br>
<P nd="1">Although the subject of cloning in the real world is controversial, in the .NET world it is still safe to use, or isn’t it?</P><P nd="2">How many times did you find yourself implementing the <CODE lang=cs nd="3">ICloneable</CODE> interface for your class, but every time you do the same code, or you do a specific code for each class. And what about, when you add a new field to the class, and you forgot to update the <CODE lang=cs nd="4">Clone</CODE> method for the new field. Believe me, this sort of thing leads to annoying bugs.</P><P nd="5">This is where my class comes to the rescue. With a little help from the reflection mechanism, I created an abstract class that implements the <CODE lang=cs nd="6">ICloneable</CODE> interface with the default behavior. Now you are probably asking yourself: What is the default behavior? Well I’m glad you asked. Default behavior for cloning, is to clone every field in the class by the following algorithm:</P><OL><LI nd="7">For each field in the class, ask if it supports the <CODE lang=cs nd="8">ICloneable</CODE> interface. <LI nd="9">If the field doesn’t support the <CODE lang=cs nd="10">ICloneable</CODE> interface, then the field is set in the regular manner, which means that if this field is a value type, then the value will be copied, but if the field is a reference type, the clone field will be pointing to the same object. <LI nd="11">If the field supports the <CODE lang=cs nd="12">ICloneable</CODE> interface, we use its <CODE lang=cs nd="13">Clone</CODE> method to set it in the clone object. <LI nd="14">If the field supports the <CODE lang=cs nd="15">IEnumerable</CODE> interface, then we need to check if it supports the <CODE lang=cs nd="16">IList</CODE> or the <CODE lang=cs nd="17">IDictionary</CODE> interface. If it does, then we iterate the collection, and for each item in the collection we ask if it supports the <CODE lang=cs nd="18">ICloneable</CODE> interface. </LI></OL><H2>How to use</H2><P nd="19">All you have to do to make your class support the <CODE lang=cs nd="20">ICloneable</CODE> interface, is to derive your class from the <CODE lang=cs nd="21">BaseObject</CODE> as follow:</P><PRE lang=cs nd="24">public class MyClass : BaseObject{    public string myStr =”test”;    public int id;}public class MyContainer : BaseObject{    public string name = “test2”;    public MyClass[] myArray= new MyClass[5];    public class MyContainer()    {        for(int i=0 ; i<5 ; i++)        {             this.myArray[I] = new MyClass();        }    }}</PRE><P nd="44">Now in the <CODE lang=cs nd="45">Main</CODE> method you can do the following:</P><PRE lang=cs nd="48">static void Main(string[] args){    MyContainer con1 = new MyContainer();    MyContainer con2 = (MyContainer)con1.Clone();   con2.myArray[0].id = 5;}</PRE><P nd="53">When inspecting the <CODE lang=cs nd="54">con2</CODE> instance you will see that the <CODE lang=cs nd="55">MyClass</CODE> instance in the first index was changed to 5, but the <CODE lang=cs nd="56">con1</CODE> instance remained without changes. So you can see that any field you will add to your class, which support the <CODE lang=cs nd="57">ICloneable</CODE> interface will be cloned as well. Furthermore, if the field supports the <CODE lang=cs nd="58">IList</CODE> interface or the <CODE lang=cs nd="59">IDictionary</CODE> interface, the method will detect it and will loop through all the items and will try to clone them as well.</P><H2>Implementation</H2><DIV class=precollapse id=premain2 style="WIDTH: 100%"><IMG id=preimg2 style="CURSOR: hand" height=9 src="http://www.codeproject.com/images/minus.gif" width=9 preid="2"> Collapse</DIV><PRE lang=cs id=pre2 style="MARGIN-TOP: 0px" nd="72">/// <summary>/// <B>BaseObject</B> class is an abstract class for you to derive from./// Every class that will be dirived from this class will support the /// <B>Clone</B> method automaticly./// The class implements the interface <I>ICloneable</I> and there /// for every object that will be derived /// from this object will support the <I>ICloneable</I> interface as well./// </summary>public abstract class BaseObject : ICloneable{    /// <summary>    /// Clone the object, and returning a reference to a cloned object.    /// </summary>    /// <returns>Reference to the new cloned     /// object.</returns>    public object Clone()    {        //First we create an instance of this specific type.        object newObject  = Activator.CreateInstance( this.GetType() );        //We get the array of fields for the new type instance.        FieldInfo[] fields = newObject.GetType().GetFields();        int i = 0;        foreach( FieldInfo fi in this.GetType().GetFields() )        {            //We <A class=iAs style="FONT-WEIGHT: normal; FONT-SIZE: 100%; PADDING-BOTTOM: 1px; COLOR: darkgreen; BORDER-BOTTOM: darkgreen 0.07em solid; BACKGROUND-COLOR: transparent; TEXT-DECORATION: underline" href="#" target=_blank itxtdid="3496922">query</A> if the fiels support the ICloneable interface.            Type ICloneType = fi.FieldType.                        GetInterface( "ICloneable" , true );            if( ICloneType != null )            {                //Getting the ICloneable interface from the object.                ICloneable IClone = (ICloneable)fi.GetValue(this);                //We use the clone method to set the new value to the field.                fields[i].SetValue( newObject , IClone.Clone() );            }            else            {                // If the field doesn't support the ICloneable                 // interface then just set it.                fields[i].SetValue( newObject , fi.GetValue(this) );            }            //Now we check if the object support the             //IEnumerable interface, so if it does            //we need to enumerate all its items and check if             //they support the ICloneable interface.            Type IEnumerableType = fi.FieldType.GetInterface                            ( "IEnumerable" , true );            if( IEnumerableType != null )            {                //Get the IEnumerable interface from the field.                IEnumerable IEnum = (IEnumerable)fi.GetValue(this);                //This version support the IList and the                 //IDictionary interfaces to iterate on collections.                Type IListType = fields[i].FieldType.GetInterface                                    ( "IList" , true );                Type IDicType = fields[i].FieldType.GetInterface                                    ( "IDictionary" , true );                int j = 0;                if( IListType != null )                {                    //Getting the IList interface.                    IList list = (IList)fields[i].GetValue(newObject);                    foreach( object obj in IEnum )                    {                        //Checking to see if the current item                         //support the ICloneable interface.                        ICloneType = obj.GetType().                            GetInterface( "ICloneable" , true );                                                if( ICloneType != null )                        {                            //If it does support the ICloneable interface,                             //we use it to set the clone of                            //the object in the list.                            ICloneable clone = (ICloneable)obj;                            list[j] = clone.Clone();                        }                        //NOTE: If the item in the list is not                         //support the ICloneable interface then in the                         //cloned list this item will be the same                         //item as in the original list                        //(as long as this type is a reference type).                        j++;                    }                }                else if( IDicType != null )                {                    //Getting the dictionary interface.                    IDictionary dic = (IDictionary)fields[i].                                        GetValue(newObject);                    j = 0;                                        foreach( DictionaryEntry de in IEnum )                    {                        //Checking to see if the item                         //support the ICloneable interface.                        ICloneType = de.Value.GetType().                            GetInterface( "ICloneable" , true );                        if( ICloneType != null )                        {                            ICloneable clone = (ICloneable)de.Value;                            dic[de.Key] = clone.Clone();                        }                        j++;                    }                }            }            i++;        }        return newObject;    }}</PRE>                                                                                                                                                                                       